<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>SVG Boolean Operations – Pure DOM + Paper.js</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
<style>
  body { font-family: system-ui, sans-serif; margin: 2rem; }
  #preview { 
    border: 1px solid #ddd; 
    background: #fafafa; 
    min-height: 300px; 
    margin: 1rem 0; 
    overflow: auto; 
  }
  #svg-container { display: none; } /* hidden – we only use it for reading */
  .controls { margin: 1.5rem 0; }
</style>
</head>
<body>

<h2>SVG Boolean Operations</h2>

<div class="controls">
  <input type="file" id="fileInput" accept=".svg" />
  <p>Upload SVG containing paths with <code>data-bool='{"op":"…","with":"…"}'</code></p>
</div>

<div id="preview"></div>
<div id="svg-container"></div>

<div class="controls">
  <button id="downloadBtn" disabled>Download processed.svg</button>
  <p id="status"></p>
</div>

<script>
// Setup Paper.js (we only use it for Path + booleans, not rendering)
paper.setup(document.createElement('canvas')); // dummy canvas – we don't display it

const fileInput = document.getElementById('fileInput');
const preview = document.getElementById('preview');
const svgContainer = document.getElementById('svg-container');
const status = document.getElementById('status');
const downloadBtn = document.getElementById('downloadBtn');

fileInput.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;

  status.textContent = 'Processing...';
  status.style.color = 'blue';
  downloadBtn.disabled = true;

  try {
    const text = await file.text();

    // 1. Put the original SVG into a hidden container
    svgContainer.innerHTML = text.trim();
    const svg = svgContainer.querySelector('svg');

    if (!svg) throw new Error('No <svg> element found');

    // 2. Find all elements that want boolean operations
    const boolElements = svg.querySelectorAll('[data-bool]');

    if (boolElements.length === 0) {
      status.textContent = 'No elements with data-bool attribute found';
      status.style.color = 'orange';
      return;
    }

    let processedCount = 0;

    // 3. Process each boolean instruction
    boolElements.forEach((baseEl) => {
      const jsonStr = baseEl.getAttribute('data-bool');
      let data;
      try {
        data = JSON.parse(jsonStr);
      } catch {
        console.warn('Invalid JSON in data-bool:', jsonStr);
        return;
      }

      const op = (data.op || '').toLowerCase().trim();
      const targetId = data.with;

      if (!['union', 'intersection', 'difference', 'xor'].includes(op)) {
        console.warn('Unsupported operation:', op);
        return;
      }
      if (!targetId) {
        console.warn('Missing "with" property');
        return;
      }

      const targetEl = document.getElementById(targetId);
      if (!targetEl || targetEl.tagName !== 'path') {
        console.warn(`Target not found or not a path: #${targetId}`);
        return;
      }

      // 4. Create Paper.js Path objects from d attributes
      const basePath = baseEl.getAttribute('d') 
        ? new paper.Path(baseEl.getAttribute('d')) 
        : null;

      const targetPath = targetEl.getAttribute('d') 
        ? new paper.Path(targetEl.getAttribute('d')) 
        : null;

      if (!basePath || !targetPath) {
        console.warn('One of the paths has no/invalid d attribute');
        return;
      }

      // 5. Perform boolean operation
      let resultPath;
      switch (op) {
        case 'union':        resultPath = basePath.unite(targetPath); break;
        case 'intersection': resultPath = basePath.intersect(targetPath); break;
        case 'difference':   resultPath = basePath.subtract(targetPath); break;
        case 'xor':          resultPath = basePath.exclude(targetPath); break;
      }

      if (!resultPath) return;

      // 6. Create new <path> element with result
      const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      
      // Copy useful attributes from original base
      ['fill', 'stroke', 'stroke-width', 'opacity', 'class'].forEach(attr => {
        if (baseEl.hasAttribute(attr)) {
          newPath.setAttribute(attr, baseEl.getAttribute(attr));
        }
      });

      newPath.setAttribute('d', resultPath.pathData);

      // Replace original base element with result
      baseEl.parentNode.replaceChild(newPath, baseEl);

      // Optional: remove the target shape too
       targetEl.remove();

      processedCount++;
    });

    // 7. Show result & prepare download
    preview.innerHTML = '';
    preview.appendChild(svg.cloneNode(true)); // visible copy

    status.textContent = `Success — ${processedCount} boolean operation${processedCount === 1 ? '' : 's'} applied`;
    status.style.color = 'darkgreen';

    downloadBtn.disabled = false;

    // Download handler
    downloadBtn.onclick = () => {
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svg);

      const blob = new Blob([svgString], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'processed.svg';
      a.click();

      URL.revokeObjectURL(url);
    };

  } catch (err) {
    status.textContent = 'Error: ' + err.message;
    status.style.color = 'red';
    console.error(err);
  }
});
</script>
</body>
</html>